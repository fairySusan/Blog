# 深度优先遍历

深度优先遍历的本质是栈结构

二叉树的深度优先遍历

```js
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
  // 递归边界，root 为空
  if(!root) {
      return 
  }
    
  // 输出当前遍历的结点值
  console.log('当前遍历的结点值是：', root.val)  
  // 递归遍历左子树 
  preorder(root.left)  
  // 递归遍历右子树  
  preorder(root.right)
}
```

# 广度优先遍历

广度优先遍历要借助队列来实现

```js
function BFS(root) {
  const queue = [] // 初始化队列queue
  // 根结点首先入队
  queue.push(root)
  // 队列不为空，说明没有遍历完全
  while(queue.length) {
    const top = queue[0] // 取出队头元素  
    // 访问 top
    console.log(top.val)
    // 如果左子树存在，左子树入队
    if(top.left) {
      queue.push(top.left)
    }
    // 如果右子树存在，右子树入队
    if(top.right) {
      queue.push(top.right)
    }
    queue.shift() // 访问完毕，队头元素出队
  }
}
```

# 获取一棵二叉树所有的路径

```js
function getBinaryTreePaths(root) {
  const result = []

  if (!root.left && !root.right) {
    return [`${root.val}`]
  }

  if (root.left) {
    const res = getBinaryTreePaths(root.left);

    res.forEach(val => {
      result.push(`${root.val}->${val}`)
    })
  }

  if (root.right) {
    getBinaryTreePaths(root.right);

    res.forEach(val => {
      result.push(`${root.val}->${val}`)
    })
  }

  return result
}
```

# 获取一棵二叉树从根节点到目标节点的路径

```js
function getBinaryTreeTargetPaths (root, target) {
  let result = ''

  if (root.val === target) {
    return root.val
  }

  if (root.left) {
    // 别忘记把target传下去
    const res = getBinaryTreeTargetPaths(root.left, target);
    if (res) {
      result = `${root.val}->${res}`
    }
  }

  if (root.right) {
    // 别忘记把target传下去
    const res = getBinaryTreeTargetPaths(root.right, target);
    if (res) {
      result = `${root.val}->${res}`
    }
  }

  return result
}
```


# 使用迭代实现深度优先遍历

深度优先遍历的实质是栈，所有迭代实现深度优先遍历依然依靠栈来实现，

要输出二叉树的所有路径，还需要一个栈

```js
function BFS(rootNode) {
  const stack = []
  stack.push(rootNode)
  const res = []

  const currPathStack = [rootNode.val]

  while(stack.length) {
    const top = stack.pop();

    const path = currPathStack.pop()

    if (!top.right && !top.left) res.push(path)

    if (top.right) {
      stack.push(top.right);
      currPathStack.push(`${path}->${top.right.val}`)
    }

    if (top.left) {
      stack.push(top.left);
      currPathStack.push(`${path}->${top.left.val}`)
    }
  }

  return res
}
```