关于链表的题目可以分为以下三类：

* 链表的处理：合并(结点的插入)、删除（删除操作画个记号，重点中的重点！）
* 链表的反转及其衍生题目
* 链表成环的问题及其衍生题目

#### 合并两个有序链表

```js
function mergeTwoList (l1, l2) {
  // 定义头结点，确保链表可以被访问到
  const head = new ListNode();
  // cur 这里就是咱们那根“针”
  let cur = head;
  // “针”开始在 l1 和 l2 间穿梭了
  while (l1 & l2) {
    // 如果 l1 的结点值较小
    if (l1.val < l2.val) {
      // 先串起 l1 的结点
      cur.next = l1;
      // l1 指针向前一步
      l1 = l1.next;
    } else {
      // l2 较小时，串起 l2 结点
      cur.next = l2;
      // l2 向前一步
      l2 = l2.next
    }
    // “针”在串起一个结点后，也会往前一步
    cur = cur.next
  }

  cur.next = l1!==null ? l1 : l2

  return head.next
}
```

#### 链表结点的删除

> 真题描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

注意是排序的链表

```js
function deleteDuplicates (head) {
  let cur = head;
  while(cur !== null && cur.next !== null) {
    if (cur.val === cur.next.val) {
      cur.next = cur.next.next
    } else {
      cur = cur.next
    }
  }

  return head
}
```

> 真题描述：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。

与上一题的区别在于 此题是将重复的元素完全删除，不留一个

```js
function deleteDuplicates (head) {
  let dummy  = new ListNode()
  dummy.next = head

  let cur = dummy
  while (cur.next && cur.next.next) {
    if (cur.next.val === cur.next.next.val) {
      let val = curr.next.val
      while (cur.next && cur.next.val === val) {
        // 若有，则删除
        cur.next = cur.next.next 
      } else {
        // 若不重复，则正常遍历
        cur = cur.next
      }
    }
  }

  return dummy.next;
}
```

